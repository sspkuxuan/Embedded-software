# 什么是信号量
为了防止出现因多个程序同时访问一个共享资源而引发的一系列问题，我们需要一种方法，它可以通过生成并使用令牌来授权，在任一时刻只能有一个执行线程访问代码的临界区。而信号量就可以提供这样的一种访问机制，让一个临界区同一时间只有一个线程在访问它，也就是说信号量是用来调协进程对共享资源的访问的。<br>

临界资源：一次只允许一个进程使用的资源。<br>
临界区：访问临界资源的程序代码片段。<br>

信号量是一个特殊的变量，程序对其访问都是原子操作，且只允许对它进行等待（即P(信号变量))和发送（即V(信号变量))信息操作。最简单的信号量是只能取0和1的变量，这也是信号量最常见的一种形式，叫做二进制信号量。而可以取多个正整数的信号量被称为通用信号量。这里主要讨论二进制信号量。<br>

信号量用来管理临界资源的。**信号量本身只是一种外部资源的标识、不具有数据交换功能**，而是通过控制其他的通信资源实现进程间通信。可以这样理解，信号量就相当于是一个计数器。当有进程对它所管理的资源进行请求时，进程先要读取信号量的值，大于0，资源可以请求，等于0，资源不可以用，这时进程会进入睡眠状态直至资源可用。当一个进程不再使用资源时，信号量+1(对应的操作称为V操作)，反之当有进程使用资源时，信号量-1(对应的操作为P操作)。对信号量的值操作均为原子操作。

# 二、信号量的工作原理
由于信号量只能进行两种操作等待和发送信号，即P(sv)和V(sv),他们的行为是这样的：<br>
* P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行。<br>
* V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1。<br>

# 三、信号量机制
Linux提供了一组精心设计的信号量接口来对信号进行操作，它们不只是针对二进制信号量。这些函数都是用来对成组的信号量值进行操作的。它们声明在头文件#include<sys/sem.h>中。<br>

## 1.semget()函数
它的作用是创建一个新信号量或取得一个已有信号量，原型为：<br>
```c
int semget(key_t key, int num_sems, int sem_flags);
```
返回值：成功返回信号量集合的标识符semid。失败返回-1。<br>

第一个参数key是整数值（唯一非零），不相关的进程可以通过它访问一个信号量，它代表程序可能要使用的某个资源，程序对所有信号量的访问都是间接的，程序先通过调用semget()函数并提供一个键，再由系统生成一个相应的信号标识符（semget()函数的返回值），只有semget()函数才直接使用信号量键，所有其他的信号量函数使用由semget()函数返回的信号量标识符。如果多个程序使用相同的key值，key将负责协调工作。<br>

第二个参数num_sems指定需要的信号量数目，它的值几乎总是1。<br>

第三个参数sem_flags是一组标志，如果想要当信号量不存在时创建一个新的信号量，可以和值IPC_CREAT做按位或操作。设置了IPC_CREAT标志后，即使给出的键是一个已有信号量的键，也不会产生错误。而IPC_CREAT | IPC_EXCL则可以创建一个新的，唯一的信号量，如果信号量已存在，返回一个错误。<br>

## 2.semop()函数
它的作用是改变信号量的值，原型为：<br>
```c
int semop(int sem_id, struct sembuf *sem_opa, size_t num_sem_ops);
```
返回值：成功返回0，失败返回-1。<br>

第一个参数：sem_id是由semget()返回的信号量标识符。<br>
第二个参数：sembuf结构的定义如下：<br>
```c
struct sembuf{
    short sem_num; // semaphore number
    short sem_op;  // semaphore operation
    short sem_flg; // operation flags
};
```
* sem_num: 信号量是以集合的形式存在的，就相当所有信号量在一个数组里边，sem_num表示信号量在集合中的编号。<br>
* sem_op:表示该信号量的操作(P操作还是V操作)。如果其值为正数，该值会加到现有的信号内含值中。通常用于释放所控资源的使用权；如果sem_op的值为负数，而其绝对值又大于信号的现值，操作将会阻塞，直到信号值大于或等于sem_op的绝对值。通常用于获取资源的使用权。<br>

struct sembuf中sem_flg:信号操作标志，它的取值有两种。IPC_NOWAIT和SEM_UNDO。<br>
* IPC_NOWAIT:对信号量的操作不能满足时，semop()不会阻塞，而是立即返回，同时设定错误信息。<br>
* SEM_UNDO: 程序结束时(不管是正常还是不正常)，保证信号值会被设定semop()调用之前的值。这样做的目的在于避免程序在异常的情况下结束未将锁定的资源解锁(死锁)，造成资源永远锁定。<br>

第三个参数：表示要操作信号量的数目
## 3.semctl()函数
该函数用来直接控制信号量信息，它的原型为：<br>
```c
int semctl(int sem_id, int sem_num, int command, ...);
```
返回值：失败返回-1。成功返回0。<br>

semid:信号量集合的编号。<br>
semnum:信号量在集合中的标号。<br>

command通常是下面两个值中的其中一个:<br>
* GETALL 读取信号量集中的所有信号量的值。<br>
* GETNCNT 返回正在等待资源的进程数目。<br>
* GETPID 返回最后一个执行semop操作的进程的PID。<br>
* GETVAL 返回信号量集中的一个信号量的值。<br>
* SETALL 设置信号量集中所有信号量的值。<br>
* SETVAL 设置信号量集中一个信号量的值。用来把信号量初始化为一个已知的值。p 这个值通过union semun中的val成员设置，其作用是在信号量第一次使用前对它进行设置。<br>
* IPC_RMID 将信号量集从内存中删除。用于删除一个已经无需继续使用的信号量标识符。<br>

如果有第四个参数，它通常是一个union semum结构，定义如下：<br>
```c
union semun {
    int val;	// 信号量使用的值
    struct semid_ds *buf;	// IPC_STAT、IPC_SET使用缓冲区
    unsigned short *arry;	// GETALL、SETALL使用的缓冲区
};
```

# 四、进程使用信号量通信
使用一个例子来说明进程间如何使用信号量来进行通信，这个例子是两个相同的程序同时向屏幕输出数据，我们可以看到如何使用信号量来使两个进程协调工作，使同一时间只有一个进程可以向屏幕输出数据。注意，如果程序是第一次被调用（为了区分，第一次调用程序时带一个要输出到屏幕中的字符作为一个参数），则需要调用set_semvalue()函数初始化信号并将message字符设置为传递给程序的参数的第一个字符，同时第一个启动的进程还负责信号量的删除工作。如果不删除信号量，它将继续在系统中存在，即使程序已经退出，它可能在你下次运行此程序时引发问题，而且信号量是一种有限的资源。<br>

在main函数中调用semget()来创建一个信号量，该函数将返回一个信号量标识符，保存于全局变量sem_id中，然后以后的函数就使用这个标识符来访问信号量。<br>

源文件为[seml.c](https://github.com/yiyading/Embedded-software/blob/master/%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%80%9A%E4%BF%A1/seml.c)<br>
* 注意：这个程序的临界区为main函数for循环下的semaphore_p()和semaphore_v()函数中间的代码。
# 五、运行
## 1.使用makefile文件编译
## 2.运行结果如下
[运行结果](https://github.com/yiyading/Embedded-software/blob/master/%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%80%9A%E4%BF%A1/img/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)<br>

# 六、例子分析
同时运行一个程序的两个实例，注意第一次运行时，要加上一个字符作为参数，例如本例中的字符‘O’，它用于区分是否为第一次调用，同时这个字符输出到屏幕中。因为每个程序都在其进入临界区后和离开临界区前打印一个字符，所以每个字符都应该成对出现，正如你看到的上图的输出那样。在main函数中循环中我们可以看到，每次进程要访问stdout（标准输出），即要输出字符时，每次都要检查信号量是否可用（即stdout有没有正在被其他进程使用）。所以，当一个进程A在调用函数semaphore_p()进入了临界区，输出字符后，调用sleep()时，另一个进程B可能想访问stdout，但是信号量的P请求操作失败，只能挂起自己的执行，当进程A调用函数semaphore_v()离开了临界区，进程B马上被恢复执行。然后进程A和进程B就这样一直循环了10次。<br>

# 七、对比例子————进程间的资源竞争
函数源码如下：<br>

[normalprint.c](https://github.com/yiyading/Embedded-software/blob/master/%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%80%9A%E4%BF%A1/normalprint.c_)<br>

运行结果如下：<br>
[运行结果](https://github.com/yiyading/Embedded-software/blob/master/%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%80%9A%E4%BF%A1/img/normalprint%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)<br>

* 例子分析：<br>
从上面的输出结果，我们可以看到字符‘X’和‘O’并不像前面的例子那样，总是成对出现，因为当第一个进程A输出了字符后，调用sleep休眠时，另一个进程B立即输出并休眠，而进程A醒来时，再继续执行输出，同样的进程B也是如此。所以输出的字符就是不成对的出现。这两个进程在竞争stdout这一共同的资源。通过两个例子的对比，我想信号量的意义和使用应该比较清楚了。<br>
